import*as n from"@jridgewell/set-array";import*as e from"@jridgewell/sourcemap-codec";import*as t from"@jridgewell/trace-mapping";var o=n;try{"default"in n&&(o=n.default)}catch(n){}var s=e;try{"default"in e&&(s=e.default)}catch(n){}var r=t;try{"default"in t&&(r=t.default)}catch(n){}var a={};(function(n,e){e(a,o,s,r)})(0,(function(n,e,t,o){const s=0;const r=1;const a=2;const c=3;const i=4;const u=-1;class GenMapping{constructor({file:n,sourceRoot:t}={}){this._names=new e.SetArray;this._sources=new e.SetArray;this._sourcesContent=[];this._mappings=[];this.file=n;this.sourceRoot=t;this._ignoreList=new e.SetArray}}function cast(n){return n}function addSegment(n,e,t,o,s,r,a,c){return addSegmentInternal(false,n,e,t,o,s,r,a,c)}function addMapping(n,e){return addMappingInternal(false,n,e)}const maybeAddSegment=(n,e,t,o,s,r,a,c)=>addSegmentInternal(true,n,e,t,o,s,r,a,c);const maybeAddMapping=(n,e)=>addMappingInternal(true,n,e);function setSourceContent(n,t,o){const{_sources:s,_sourcesContent:r}=cast(n);const a=e.put(s,t);r[a]=o}function setIgnore(n,t,o=true){const{_sources:s,_sourcesContent:r,_ignoreList:a}=cast(n);const c=e.put(s,t);c===r.length&&(r[c]=null);o?e.put(a,c):e.remove(a,c)}function toDecodedMap(n){const{_mappings:e,_sources:t,_sourcesContent:o,_names:s,_ignoreList:r}=cast(n);removeEmptyFinalLines(e);return{version:3,file:n.file||void 0,names:s.array,sourceRoot:n.sourceRoot||void 0,sources:t.array,sourcesContent:o,mappings:e,ignoreList:r.array}}function toEncodedMap(n){const e=toDecodedMap(n);return Object.assign(Object.assign({},e),{mappings:t.encode(e.mappings)})}function fromMap(n){const e=new o.TraceMap(n);const t=new GenMapping({file:e.file,sourceRoot:e.sourceRoot});putAll(cast(t)._names,e.names);putAll(cast(t)._sources,e.sources);cast(t)._sourcesContent=e.sourcesContent||e.sources.map((()=>null));cast(t)._mappings=o.decodedMappings(e);e.ignoreList&&putAll(cast(t)._ignoreList,e.ignoreList);return t}function allMappings(n){const e=[];const{_mappings:t,_sources:o,_names:u}=cast(n);for(let n=0;n<t.length;n++){const l=t[n];for(let t=0;t<l.length;t++){const p=l[t];const d={line:n+1,column:p[s]};let g;let f;let m;if(p.length!==1){g=o.array[p[r]];f={line:p[a]+1,column:p[c]};p.length===5&&(m=u.array[p[i]])}e.push({generated:d,source:g,original:f,name:m})}}return e}function addSegmentInternal(n,t,o,s,r,a,c,i,l){const{_mappings:p,_sources:d,_sourcesContent:g,_names:f}=cast(t);const m=getLine(p,o);const M=getColumnIndex(m,s);if(!r){if(n&&skipSourceless(m,M))return;return insert(m,M,[s])}const _=e.put(d,r);const h=i?e.put(f,i):u;_===g.length&&(g[_]=l!==null&&l!==void 0?l:null);if(!n||!skipSource(m,M,_,a,c,h))return insert(m,M,i?[s,_,a,c,h]:[s,_,a,c])}function getLine(n,e){for(let t=n.length;t<=e;t++)n[t]=[];return n[e]}function getColumnIndex(n,e){let t=n.length;for(let o=t-1;o>=0;t=o--){const t=n[o];if(e>=t[s])break}return t}function insert(n,e,t){for(let t=n.length;t>e;t--)n[t]=n[t-1];n[e]=t}function removeEmptyFinalLines(n){const{length:e}=n;let t=e;for(let e=t-1;e>=0;t=e,e--)if(n[e].length>0)break;t<e&&(n.length=t)}function putAll(n,t){for(let o=0;o<t.length;o++)e.put(n,t[o])}function skipSourceless(n,e){if(e===0)return true;const t=n[e-1];return t.length===1}function skipSource(n,e,t,o,s,l){if(e===0)return false;const p=n[e-1];return p.length!==1&&(t===p[r]&&o===p[a]&&s===p[c]&&l===(p.length===5?p[i]:u))}function addMappingInternal(n,e,t){const{generated:o,source:s,original:r,name:a,content:c}=t;return s?addSegmentInternal(n,e,o.line-1,o.column,s,r.line-1,r.column,a,c):addSegmentInternal(n,e,o.line-1,o.column,null,null,null,null,null)}n.GenMapping=GenMapping;n.addMapping=addMapping;n.addSegment=addSegment;n.allMappings=allMappings;n.fromMap=fromMap;n.maybeAddMapping=maybeAddMapping;n.maybeAddSegment=maybeAddSegment;n.setIgnore=setIgnore;n.setSourceContent=setSourceContent;n.toDecodedMap=toDecodedMap;n.toEncodedMap=toEncodedMap;Object.defineProperty(n,"__esModule",{value:true})}));const c=a.GenMapping,i=a.addMapping,u=a.addSegment,l=a.allMappings,p=a.fromMap,d=a.maybeAddMapping,g=a.maybeAddSegment,f=a.setIgnore,m=a.setSourceContent,M=a.toDecodedMap,_=a.toEncodedMap,h=a.__esModule;export{c as GenMapping,h as __esModule,i as addMapping,u as addSegment,l as allMappings,a as default,p as fromMap,d as maybeAddMapping,g as maybeAddSegment,f as setIgnore,m as setSourceContent,M as toDecodedMap,_ as toEncodedMap};

