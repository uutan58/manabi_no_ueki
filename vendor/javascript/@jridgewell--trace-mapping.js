import*as e from"@jridgewell/sourcemap-codec";import*as n from"@jridgewell/resolve-uri";var t=e;try{"default"in e&&(t=e.default)}catch(e){}var o=n;try{"default"in n&&(o=n.default)}catch(e){}var r={};(function(e,n){n(r,t,o)})(0,(function(e,n,t){function resolve(e,n){n&&!n.endsWith("/")&&(n+="/");return t(e,n)}function stripFilename(e){if(!e)return"";const n=e.lastIndexOf("/");return e.slice(0,n+1)}const o=0;const r=1;const s=2;const c=3;const i=4;const l=1;const u=2;function maybeSort(e,n){const t=nextUnsortedSegmentLine(e,0);if(t===e.length)return e;n||(e=e.slice());for(let o=t;o<e.length;o=nextUnsortedSegmentLine(e,o+1))e[o]=sortSegments(e[o],n);return e}function nextUnsortedSegmentLine(e,n){for(let t=n;t<e.length;t++)if(!isSorted(e[t]))return t;return e.length}function isSorted(e){for(let n=1;n<e.length;n++)if(e[n][o]<e[n-1][o])return false;return true}function sortSegments(e,n){n||(e=e.slice());return e.sort(sortComparator)}function sortComparator(e,n){return e[o]-n[o]}let a=false;function binarySearch(e,n,t,r){while(t<=r){const s=t+(r-t>>1);const c=e[s][o]-n;if(c===0){a=true;return s}c<0?t=s+1:r=s-1}a=false;return t-1}function upperBound(e,n,t){for(let r=t+1;r<e.length;t=r++)if(e[r][o]!==n)break;return t}function lowerBound(e,n,t){for(let r=t-1;r>=0;t=r--)if(e[r][o]!==n)break;return t}function memoizedState(){return{lastKey:-1,lastNeedle:-1,lastIndex:-1}}function memoizedBinarySearch(e,n,t,r){const{lastKey:s,lastNeedle:c,lastIndex:i}=t;let l=0;let u=e.length-1;if(r===s){if(n===c){a=i!==-1&&e[i][o]===n;return i}n>=c?l=i===-1?0:i:u=i}t.lastKey=r;t.lastNeedle=n;return t.lastIndex=binarySearch(e,n,l,u)}function buildBySources(e,n){const t=n.map(buildNullArray);for(let i=0;i<e.length;i++){const l=e[i];for(let e=0;e<l.length;e++){const u=l[e];if(u.length===1)continue;const a=u[r];const d=u[s];const p=u[c];const f=t[a];const g=f[d]||(f[d]=[]);const m=n[a];let h=upperBound(g,p,memoizedBinarySearch(g,p,m,d));m.lastIndex=++h;insert(g,h,[p,i,u[o]])}}return t}function insert(e,n,t){for(let t=e.length;t>n;t--)e[t]=e[t-1];e[n]=t}function buildNullArray(){return{__proto__:null}}const AnyMap=function(e,n){const t=parse(e);if(!("sections"in t))return new TraceMap(t,n);const o=[];const r=[];const s=[];const c=[];const i=[];recurse(t,n,o,r,s,c,i,0,0,Infinity,Infinity);const l={version:3,file:t.file,names:c,sources:r,sourcesContent:s,mappings:o,ignoreList:i};return presortedDecodedMap(l)};function parse(e){return typeof e==="string"?JSON.parse(e):e}function recurse(e,n,t,o,r,s,c,i,l,u,a){const{sections:d}=e;for(let e=0;e<d.length;e++){const{map:p,offset:f}=d[e];let g=u;let m=a;if(e+1<d.length){const n=d[e+1].offset;g=Math.min(u,i+n.line);g===u?m=Math.min(a,l+n.column):g<u&&(m=l+n.column)}addSection(p,n,t,o,r,s,c,i+f.line,l+f.column,g,m)}}function addSection(e,n,t,l,u,a,d,p,f,g,m){const h=parse(e);if("sections"in h)return recurse(...arguments);const M=new TraceMap(h,n);const S=l.length;const _=a.length;const y=decodedMappings(M);const{resolvedSources:v,sourcesContent:b,ignoreList:P}=M;append(l,v);append(a,M.names);if(b)append(u,b);else for(let e=0;e<v.length;e++)u.push(null);if(P)for(let e=0;e<P.length;e++)d.push(P[e]+S);for(let e=0;e<y.length;e++){const n=p+e;if(n>g)return;const l=getLine(t,n);const u=e===0?f:0;const a=y[e];for(let e=0;e<a.length;e++){const t=a[e];const d=u+t[o];if(n===g&&d>=m)return;if(t.length===1){l.push([d]);continue}const p=S+t[r];const f=t[s];const h=t[c];l.push(t.length===4?[d,p,f,h]:[d,p,f,h,_+t[i]])}}}function append(e,n){for(let t=0;t<n.length;t++)e.push(n[t])}function getLine(e,n){for(let t=e.length;t<=n;t++)e[t]=[];return e[n]}const d="`line` must be greater than 0 (lines start at line 1)";const p="`column` must be greater than or equal to 0 (columns start at column 0)";const f=-1;const g=1;class TraceMap{constructor(e,n){const t=typeof e==="string";if(!t&&e._decodedMemo)return e;const o=t?JSON.parse(e):e;const{version:r,file:s,names:c,sourceRoot:i,sources:l,sourcesContent:u}=o;this.version=r;this.file=s;this.names=c||[];this.sourceRoot=i;this.sources=l;this.sourcesContent=u;this.ignoreList=o.ignoreList||o.x_google_ignoreList||void 0;const a=resolve(i||"",stripFilename(n));this.resolvedSources=l.map((e=>resolve(e||"",a)));const{mappings:d}=o;if(typeof d==="string"){this._encoded=d;this._decoded=void 0}else{this._encoded=void 0;this._decoded=maybeSort(d,t)}this._decodedMemo=memoizedState();this._bySources=void 0;this._bySourceMemos=void 0}}function cast(e){return e}function encodedMappings(e){var t;var o;return(t=(o=cast(e))._encoded)!==null&&t!==void 0?t:o._encoded=n.encode(cast(e)._decoded)}function decodedMappings(e){var t;return(t=cast(e))._decoded||(t._decoded=n.decode(cast(e)._encoded))}function traceSegment(e,n,t){const o=decodedMappings(e);if(n>=o.length)return null;const r=o[n];const s=traceSegmentInternal(r,cast(e)._decodedMemo,n,t,g);return s===-1?null:r[s]}function originalPositionFor(e,n){let{line:t,column:o,bias:l}=n;t--;if(t<0)throw new Error(d);if(o<0)throw new Error(p);const u=decodedMappings(e);if(t>=u.length)return OMapping(null,null,null,null);const a=u[t];const f=traceSegmentInternal(a,cast(e)._decodedMemo,t,o,l||g);if(f===-1)return OMapping(null,null,null,null);const m=a[f];if(m.length===1)return OMapping(null,null,null,null);const{names:h,resolvedSources:M}=e;return OMapping(M[m[r]],m[s]+1,m[c],m.length===5?h[m[i]]:null)}function generatedPositionFor(e,n){const{source:t,line:o,column:r,bias:s}=n;return generatedPosition(e,t,o,r,s||g,false)}function allGeneratedPositionsFor(e,n){const{source:t,line:o,column:r,bias:s}=n;return generatedPosition(e,t,o,r,s||f,true)}function eachMapping(e,n){const t=decodedMappings(e);const{names:o,resolvedSources:r}=e;for(let e=0;e<t.length;e++){const s=t[e];for(let t=0;t<s.length;t++){const c=s[t];const i=e+1;const l=c[0];let u=null;let a=null;let d=null;let p=null;if(c.length!==1){u=r[c[1]];a=c[2]+1;d=c[3]}c.length===5&&(p=o[c[4]]);n({generatedLine:i,generatedColumn:l,source:u,originalLine:a,originalColumn:d,name:p})}}}function sourceIndex(e,n){const{sources:t,resolvedSources:o}=e;let r=t.indexOf(n);r===-1&&(r=o.indexOf(n));return r}function sourceContentFor(e,n){const{sourcesContent:t}=e;if(t==null)return null;const o=sourceIndex(e,n);return o===-1?null:t[o]}function isIgnored(e,n){const{ignoreList:t}=e;if(t==null)return false;const o=sourceIndex(e,n);return o!==-1&&t.includes(o)}function presortedDecodedMap(e,n){const t=new TraceMap(clone(e,[]),n);cast(t)._decoded=e.mappings;return t}function decodedMap(e){return clone(e,decodedMappings(e))}function encodedMap(e){return clone(e,encodedMappings(e))}function clone(e,n){return{version:e.version,file:e.file,names:e.names,sourceRoot:e.sourceRoot,sources:e.sources,sourcesContent:e.sourcesContent,mappings:n,ignoreList:e.ignoreList||e.x_google_ignoreList}}function OMapping(e,n,t,o){return{source:e,line:n,column:t,name:o}}function GMapping(e,n){return{line:e,column:n}}function traceSegmentInternal(e,n,t,o,r){let s=memoizedBinarySearch(e,o,n,t);a?s=(r===f?upperBound:lowerBound)(e,o,s):r===f&&s++;return s===-1||s===e.length?-1:s}function sliceGeneratedPositions(e,n,t,r,s){let c=traceSegmentInternal(e,n,t,r,g);a||s!==f||c++;if(c===-1||c===e.length)return[];const i=a?r:e[c][o];a||(c=lowerBound(e,i,c));const d=upperBound(e,i,c);const p=[];for(;c<=d;c++){const n=e[c];p.push(GMapping(n[l]+1,n[u]))}return p}function generatedPosition(e,n,t,o,r,s){var c;t--;if(t<0)throw new Error(d);if(o<0)throw new Error(p);const{sources:i,resolvedSources:a}=e;let f=i.indexOf(n);f===-1&&(f=a.indexOf(n));if(f===-1)return s?[]:GMapping(null,null);const g=(c=cast(e))._bySources||(c._bySources=buildBySources(decodedMappings(e),cast(e)._bySourceMemos=i.map(memoizedState)));const m=g[f][t];if(m==null)return s?[]:GMapping(null,null);const h=cast(e)._bySourceMemos[f];if(s)return sliceGeneratedPositions(m,h,t,o,r);const M=traceSegmentInternal(m,h,t,o,r);if(M===-1)return GMapping(null,null);const S=m[M];return GMapping(S[l]+1,S[u])}e.AnyMap=AnyMap;e.GREATEST_LOWER_BOUND=g;e.LEAST_UPPER_BOUND=f;e.TraceMap=TraceMap;e.allGeneratedPositionsFor=allGeneratedPositionsFor;e.decodedMap=decodedMap;e.decodedMappings=decodedMappings;e.eachMapping=eachMapping;e.encodedMap=encodedMap;e.encodedMappings=encodedMappings;e.generatedPositionFor=generatedPositionFor;e.isIgnored=isIgnored;e.originalPositionFor=originalPositionFor;e.presortedDecodedMap=presortedDecodedMap;e.sourceContentFor=sourceContentFor;e.traceSegment=traceSegment}));const s=r.AnyMap,c=r.GREATEST_LOWER_BOUND,i=r.LEAST_UPPER_BOUND,l=r.TraceMap,u=r.allGeneratedPositionsFor,a=r.decodedMap,d=r.decodedMappings,p=r.eachMapping,f=r.encodedMap,g=r.encodedMappings,m=r.generatedPositionFor,h=r.isIgnored,M=r.originalPositionFor,S=r.presortedDecodedMap,_=r.sourceContentFor,y=r.traceSegment;export{s as AnyMap,c as GREATEST_LOWER_BOUND,i as LEAST_UPPER_BOUND,l as TraceMap,u as allGeneratedPositionsFor,a as decodedMap,d as decodedMappings,r as default,p as eachMapping,f as encodedMap,g as encodedMappings,m as generatedPositionFor,h as isIgnored,M as originalPositionFor,S as presortedDecodedMap,_ as sourceContentFor,y as traceSegment};

